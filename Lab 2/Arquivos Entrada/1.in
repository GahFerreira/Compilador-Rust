TOKEN_fn fn
TOKEN_ID f
TOKEN_PARENTHESIS_OP (
TOKEN_PARENTHESIS_CL )
TOKEN_ARROW ->
TOKEN_i32 i32
TOKEN_CURLY_OP {
TOKEN_let let
TOKEN_mut mut
TOKEN_ID x
TOKEN_COLON :
TOKEN_i32 i32
TOKEN_SEMICOLON ;
TOKEN_ID x
TOKEN_ASSIGN =
TOKEN_INT_LITERAL 15
TOKEN_PLUS +
TOKEN_INT_LITERAL 0b1
TOKEN_PLUS +
TOKEN_INT_LITERAL 0o7
TOKEN_PLUS +
TOKEN_INT_LITERAL 0xF
TOKEN_SEMICOLON ;
TOKEN_ID x
TOKEN_ASSIGN =
TOKEN_INT_LITERAL 15
TOKEN_PLUS +
TOKEN_INT_LITERAL 0o7
TOKEN_MULTIPLY *
TOKEN_INT_LITERAL 0xF
TOKEN_DIVIDE /
TOKEN_INT_LITERAL 1
TOKEN_REMAINDER %
TOKEN_INT_LITERAL 0b1
TOKEN_SEMICOLON ;
TOKEN_ID x
TOKEN_ASSIGN =
TOKEN_INT_LITERAL 15
TOKEN_PLUS +
TOKEN_INT_LITERAL 0b1
TOKEN_PLUS +
TOKEN_INT_LITERAL 0o7
TOKEN_PLUS +
TOKEN_INT_LITERAL 0xF
TOKEN_SEMICOLON ;
TOKEN_ID x
TOKEN_ASSIGN =
TOKEN_ID x
TOKEN_PLUS +
TOKEN_PARENTHESIS_OP (
TOKEN_INT_LITERAL 15
TOKEN_PLUS +
TOKEN_INT_LITERAL 0b1
TOKEN_PARENTHESIS_CL )
TOKEN_MULTIPLY *
TOKEN_PARENTHESIS_OP (
TOKEN_INT_LITERAL 15
TOKEN_MINUS -
TOKEN_INT_LITERAL 0b1
TOKEN_PARENTHESIS_CL )
TOKEN_SEMICOLON ;
TOKEN_let let
TOKEN_mut mut
TOKEN_ID y
TOKEN_COLON :
TOKEN_bool bool
TOKEN_SEMICOLON ;
TOKEN_ID y
TOKEN_ASSIGN =
TOKEN_PARENTHESIS_OP (
TOKEN_INT_LITERAL 1
TOKEN_LESS <
TOKEN_INT_LITERAL 2
TOKEN_AND &&
TOKEN_INT_LITERAL 2
TOKEN_LESS <
TOKEN_INT_LITERAL 3
TOKEN_PARENTHESIS_CL )
TOKEN_LESS_EQUAL <=
TOKEN_PARENTHESIS_OP (
TOKEN_INT_LITERAL 2
TOKEN_GREATER >
TOKEN_INT_LITERAL 3
TOKEN_PARENTHESIS_CL )
TOKEN_SEMICOLON ;
TOKEN_ID y
TOKEN_ASSIGN =
TOKEN_NOT !
TOKEN_ID y
TOKEN_OR ||
TOKEN_PARENTHESIS_OP (
TOKEN_INT_LITERAL 1
TOKEN_DIFFERENT !=
TOKEN_INT_LITERAL 0
TOKEN_PARENTHESIS_CL )
TOKEN_GREATER_EQUAL >=
TOKEN_PARENTHESIS_OP (
TOKEN_INT_LITERAL 1
TOKEN_EQUAL ==
TOKEN_INT_LITERAL 0
TOKEN_PARENTHESIS_CL )
TOKEN_SEMICOLON ;
TOKEN_if if
TOKEN_ID y
TOKEN_CURLY_OP {
TOKEN_let let
TOKEN_ID z
TOKEN_COLON :
TOKEN_bool bool
TOKEN_SEMICOLON ;
TOKEN_ID z
TOKEN_ASSIGN =
TOKEN_true true
TOKEN_SEMICOLON ;
TOKEN_ID y
TOKEN_ASSIGN =
TOKEN_ID y
TOKEN_EQUAL ==
TOKEN_ID z
TOKEN_SEMICOLON ;
TOKEN_CURLY_CL }
TOKEN_while while
TOKEN_ID x
TOKEN_GREATER >
TOKEN_INT_LITERAL 0
TOKEN_CURLY_OP {
TOKEN_if if
TOKEN_ID x
TOKEN_LESS <
TOKEN_INT_LITERAL 0
TOKEN_CURLY_OP {
TOKEN_ID x
TOKEN_ASSIGN =
TOKEN_INT_LITERAL 0
TOKEN_MINUS -
TOKEN_ID x
TOKEN_SEMICOLON ;
TOKEN_CURLY_CL }
TOKEN_ID x
TOKEN_ASSIGN =
TOKEN_ID x
TOKEN_MINUS -
TOKEN_INT_LITERAL 1
TOKEN_SEMICOLON ;
TOKEN_CURLY_CL }
TOKEN_if if
TOKEN_ID x
TOKEN_EQUAL ==
TOKEN_INT_LITERAL 0
TOKEN_CURLY_OP {
TOKEN_ID x
TOKEN_ASSIGN =
TOKEN_INT_LITERAL 10
TOKEN_SEMICOLON ;
TOKEN_CURLY_CL }
TOKEN_else else
TOKEN_CURLY_OP {
TOKEN_ID x
TOKEN_ASSIGN =
TOKEN_MINUS -
TOKEN_INT_LITERAL 10
TOKEN_PLUS +
TOKEN_ID g
TOKEN_PARENTHESIS_OP (
TOKEN_INT_LITERAL 0b1
TOKEN_COMMA ,
TOKEN_INT_LITERAL 0o5
TOKEN_COMMA ,
TOKEN_INT_LITERAL 0xAA
TOKEN_PARENTHESIS_CL )
TOKEN_SEMICOLON ;
TOKEN_CURLY_CL }
TOKEN_let let
TOKEN_ID arr
TOKEN_COLON :
TOKEN_BRACKET_OP [
TOKEN_i32 i32
TOKEN_SEMICOLON ;
TOKEN_INT_LITERAL 3
TOKEN_BRACKET_CL ]
TOKEN_SEMICOLON ;
TOKEN_ID arr
TOKEN_ASSIGN =
TOKEN_BRACKET_OP [
TOKEN_INT_LITERAL 15
TOKEN_COMMA ,
TOKEN_INT_LITERAL 20
TOKEN_COMMA ,
TOKEN_INT_LITERAL 30
TOKEN_BRACKET_CL ]
TOKEN_SEMICOLON ;
TOKEN_ID x
TOKEN_ASSIGN =
TOKEN_ID x
TOKEN_PLUS +
TOKEN_ID arr
TOKEN_BRACKET_OP [
TOKEN_INT_LITERAL 2
TOKEN_BRACKET_CL ]
TOKEN_SEMICOLON ;
TOKEN_ID x
TOKEN_CURLY_CL }
TOKEN_fn fn
TOKEN_ID g
TOKEN_PARENTHESIS_OP (
TOKEN_ID a
TOKEN_COLON :
TOKEN_i32 i32
TOKEN_COMMA ,
TOKEN_ID b
TOKEN_COLON :
TOKEN_i32 i32
TOKEN_COMMA ,
TOKEN_ID c
TOKEN_COLON :
TOKEN_i32 i32
TOKEN_PARENTHESIS_CL )
TOKEN_ARROW ->
TOKEN_i32 i32
TOKEN_CURLY_OP {
TOKEN_ID a
TOKEN_PLUS +
TOKEN_ID b
TOKEN_MULTIPLY *
TOKEN_ID c
TOKEN_CURLY_CL }
TOKEN_fn fn
TOKEN_ID main
TOKEN_PARENTHESIS_OP (
TOKEN_PARENTHESIS_CL )
TOKEN_ARROW ->
TOKEN_PARENTHESIS_OP (
TOKEN_PARENTHESIS_CL )
TOKEN_CURLY_OP {
TOKEN_ID println
TOKEN_NOT !
TOKEN_PARENTHESIS_OP (
TOKEN_STRING_LITERAL "{}"
TOKEN_COMMA ,
TOKEN_ID f
TOKEN_PARENTHESIS_OP (
TOKEN_PARENTHESIS_CL )
TOKEN_PARENTHESIS_CL )
TOKEN_SEMICOLON ;
TOKEN_CURLY_CL }
$ $
