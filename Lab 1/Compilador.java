/* Generated By:JavaCC: Do not edit this line. Compilador.java */
public class Compilador implements CompiladorConstants {
  public static void main(String args[]) throws ParseException, TokenMgrError
  {
    Compilador parser = new Compilador(System.in);

    parser.Inicio();
  }

  static final public void Inicio() throws ParseException {
  Token t;
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TOKEN_bool:
      case TOKEN_i8:
      case TOKEN_i16:
      case TOKEN_i32:
      case TOKEN_i64:
      case TOKEN_i128:
      case TOKEN_u8:
      case TOKEN_u16:
      case TOKEN_u32:
      case TOKEN_u64:
      case TOKEN_u128:
      case TOKEN_f32:
      case TOKEN_f64:
      case TOKEN_char:
      case TOKEN_str:
      case TOKEN_as:
      case TOKEN_async:
      case TOKEN_await:
      case TOKEN_break:
      case TOKEN_const:
      case TOKEN_continue:
      case TOKEN_crate:
      case TOKEN_dyn:
      case TOKEN_else:
      case TOKEN_enum:
      case TOKEN_extern:
      case TOKEN_false:
      case TOKEN_fn:
      case TOKEN_for:
      case TOKEN_if:
      case TOKEN_impl:
      case TOKEN_in:
      case TOKEN_let:
      case TOKEN_loop:
      case TOKEN_match:
      case TOKEN_mod:
      case TOKEN_move:
      case TOKEN_mut:
      case TOKEN_pub:
      case TOKEN_ref:
      case TOKEN_return:
      case TOKEN_self:
      case TOKEN_Self:
      case TOKEN_static:
      case TOKEN_struct:
      case TOKEN_super:
      case TOKEN_trait:
      case TOKEN_true:
      case TOKEN_type:
      case TOKEN_unsafe:
      case TOKEN_use:
      case TOKEN_where:
      case TOKEN_while:
      case TOKEN_ARROW:
      case TOKEN_PLUS_ASSIGN:
      case TOKEN_PLUS:
      case TOKEN_MINUS_ASSIGN:
      case TOKEN_MINUS:
      case TOKEN_MULTIPLY_ASSIGN:
      case TOKEN_MULTIPLY:
      case TOKEN_DIVIDE_ASSIGN:
      case TOKEN_DIVIDE:
      case TOKEN_REMAINDER_ASSIGN:
      case TOKEN_REMAINDER:
      case TOKEN_OR:
      case TOKEN_BIT_OR_ASSIGN:
      case TOKEN_BIT_OR:
      case TOKEN_AND:
      case TOKEN_BIT_AND_ASSIGN:
      case TOKEN_BIT_AND:
      case TOKEN_BIT_XOR_ASSIGN:
      case TOKEN_BIT_XOR:
      case TOKEN_COMMA:
      case TOKEN_DOT_DOT_ASSIGN:
      case TOKEN_DOT_DOT:
      case TOKEN_DOT:
      case TOKEN_COLON:
      case TOKEN_SEMICOLON:
      case TOKEN_LEFT_SHIFT_ASSIGN:
      case TOKEN_LEFT_SHIFT:
      case TOKEN_RIGHT_SHIFT_ASSIGN:
      case TOKEN_RIGHT_SHIFT:
      case TOKEN_LESS_EQUAL:
      case TOKEN_LESS:
      case TOKEN_GREATER_EQUAL:
      case TOKEN_GREATER:
      case TOKEN_DIFFERENT:
      case TOKEN_NOT:
      case TOKEN_EQUAL:
      case TOKEN_ASSIGN:
      case TOKEN_OPEN_PARENTHESIS:
      case TOKEN_CLOSE_PARENTHESIS:
      case TOKEN_OPEN_BRACKET:
      case TOKEN_CLOSE_BRACKET:
      case TOKEN_OPEN_BRACE:
      case TOKEN_CLOSE_BRACE:
      case TOKEN_QUESTION:
      case TOKEN_AT:
      case TOKEN_TILDE:
      case TOKEN_DECIMAL_FLOAT_LITERAL:
      case TOKEN_BINARY_LITERAL:
      case TOKEN_OCTAL_LITERAL:
      case TOKEN_DECIMAL_LITERAL:
      case TOKEN_HEX_LITERAL:
      case TOKEN_CHAR_LITERAL:
      case TOKEN_STRING_LITERAL:
      case TOKEN_ID:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TOKEN_bool:
        t = jj_consume_token(TOKEN_bool);
      System.out.println("TOKEN_bool " + t.image);
        break;
      case TOKEN_i8:
        t = jj_consume_token(TOKEN_i8);
      System.out.println("TOKEN_i8 " + t.image);
        break;
      case TOKEN_i16:
        t = jj_consume_token(TOKEN_i16);
      System.out.println("TOKEN_i16 " + t.image);
        break;
      case TOKEN_i32:
        t = jj_consume_token(TOKEN_i32);
      System.out.println("TOKEN_i32 " + t.image);
        break;
      case TOKEN_i64:
        t = jj_consume_token(TOKEN_i64);
      System.out.println("TOKEN_i64 " + t.image);
        break;
      case TOKEN_i128:
        t = jj_consume_token(TOKEN_i128);
      System.out.println("TOKEN_i128 " + t.image);
        break;
      case TOKEN_u8:
        t = jj_consume_token(TOKEN_u8);
      System.out.println("TOKEN_u8 " + t.image);
        break;
      case TOKEN_u16:
        t = jj_consume_token(TOKEN_u16);
      System.out.println("TOKEN_u16 " + t.image);
        break;
      case TOKEN_u32:
        t = jj_consume_token(TOKEN_u32);
      System.out.println("TOKEN_u32 " + t.image);
        break;
      case TOKEN_u64:
        t = jj_consume_token(TOKEN_u64);
      System.out.println("TOKEN_u64 " + t.image);
        break;
      case TOKEN_u128:
        t = jj_consume_token(TOKEN_u128);
      System.out.println("TOKEN_u128 " + t.image);
        break;
      case TOKEN_f32:
        t = jj_consume_token(TOKEN_f32);
      System.out.println("TOKEN_f32 " + t.image);
        break;
      case TOKEN_f64:
        t = jj_consume_token(TOKEN_f64);
      System.out.println("TOKEN_f64 " + t.image);
        break;
      case TOKEN_char:
        t = jj_consume_token(TOKEN_char);
      System.out.println("TOKEN_char " + t.image);
        break;
      case TOKEN_str:
        t = jj_consume_token(TOKEN_str);
      System.out.println("TOKEN_str " + t.image);
        break;
      case TOKEN_as:
        t = jj_consume_token(TOKEN_as);
      System.out.println("TOKEN_as " + t.image);
        break;
      case TOKEN_async:
        t = jj_consume_token(TOKEN_async);
      System.out.println("TOKEN_async " + t.image);
        break;
      case TOKEN_await:
        t = jj_consume_token(TOKEN_await);
      System.out.println("TOKEN_await " + t.image);
        break;
      case TOKEN_break:
        t = jj_consume_token(TOKEN_break);
      System.out.println("TOKEN_break " + t.image);
        break;
      case TOKEN_const:
        t = jj_consume_token(TOKEN_const);
      System.out.println("TOKEN_const " + t.image);
        break;
      case TOKEN_continue:
        t = jj_consume_token(TOKEN_continue);
      System.out.println("TOKEN_continue " + t.image);
        break;
      case TOKEN_crate:
        t = jj_consume_token(TOKEN_crate);
      System.out.println("TOKEN_crate " + t.image);
        break;
      case TOKEN_dyn:
        t = jj_consume_token(TOKEN_dyn);
      System.out.println("TOKEN_dyn " + t.image);
        break;
      case TOKEN_else:
        t = jj_consume_token(TOKEN_else);
      System.out.println("TOKEN_else " + t.image);
        break;
      case TOKEN_enum:
        t = jj_consume_token(TOKEN_enum);
      System.out.println("TOKEN_enum " + t.image);
        break;
      case TOKEN_extern:
        t = jj_consume_token(TOKEN_extern);
      System.out.println("TOKEN_extern " + t.image);
        break;
      case TOKEN_false:
        t = jj_consume_token(TOKEN_false);
      System.out.println("TOKEN_false " + t.image);
        break;
      case TOKEN_fn:
        t = jj_consume_token(TOKEN_fn);
      System.out.println("TOKEN_fn " + t.image);
        break;
      case TOKEN_for:
        t = jj_consume_token(TOKEN_for);
      System.out.println("TOKEN_for " + t.image);
        break;
      case TOKEN_if:
        t = jj_consume_token(TOKEN_if);
      System.out.println("TOKEN_if " + t.image);
        break;
      case TOKEN_impl:
        t = jj_consume_token(TOKEN_impl);
      System.out.println("TOKEN_impl " + t.image);
        break;
      case TOKEN_in:
        t = jj_consume_token(TOKEN_in);
      System.out.println("TOKEN_in " + t.image);
        break;
      case TOKEN_let:
        t = jj_consume_token(TOKEN_let);
      System.out.println("TOKEN_let " + t.image);
        break;
      case TOKEN_loop:
        t = jj_consume_token(TOKEN_loop);
      System.out.println("TOKEN_loop " + t.image);
        break;
      case TOKEN_match:
        t = jj_consume_token(TOKEN_match);
      System.out.println("TOKEN_match " + t.image);
        break;
      case TOKEN_mod:
        t = jj_consume_token(TOKEN_mod);
      System.out.println("TOKEN_mod " + t.image);
        break;
      case TOKEN_move:
        t = jj_consume_token(TOKEN_move);
      System.out.println("TOKEN_move " + t.image);
        break;
      case TOKEN_mut:
        t = jj_consume_token(TOKEN_mut);
      System.out.println("TOKEN_mut " + t.image);
        break;
      case TOKEN_pub:
        t = jj_consume_token(TOKEN_pub);
      System.out.println("TOKEN_pub " + t.image);
        break;
      case TOKEN_ref:
        t = jj_consume_token(TOKEN_ref);
      System.out.println("TOKEN_ref " + t.image);
        break;
      case TOKEN_return:
        t = jj_consume_token(TOKEN_return);
      System.out.println("TOKEN_return " + t.image);
        break;
      case TOKEN_self:
        t = jj_consume_token(TOKEN_self);
      System.out.println("TOKEN_self " + t.image);
        break;
      case TOKEN_Self:
        t = jj_consume_token(TOKEN_Self);
      System.out.println("TOKEN_Self " + t.image);
        break;
      case TOKEN_static:
        t = jj_consume_token(TOKEN_static);
      System.out.println("TOKEN_static " + t.image);
        break;
      case TOKEN_struct:
        t = jj_consume_token(TOKEN_struct);
      System.out.println("TOKEN_struct " + t.image);
        break;
      case TOKEN_super:
        t = jj_consume_token(TOKEN_super);
      System.out.println("TOKEN_super " + t.image);
        break;
      case TOKEN_trait:
        t = jj_consume_token(TOKEN_trait);
      System.out.println("TOKEN_trait " + t.image);
        break;
      case TOKEN_true:
        t = jj_consume_token(TOKEN_true);
      System.out.println("TOKEN_true " + t.image);
        break;
      case TOKEN_type:
        t = jj_consume_token(TOKEN_type);
      System.out.println("TOKEN_type " + t.image);
        break;
      case TOKEN_unsafe:
        t = jj_consume_token(TOKEN_unsafe);
      System.out.println("TOKEN_unsafe " + t.image);
        break;
      case TOKEN_use:
        t = jj_consume_token(TOKEN_use);
      System.out.println("TOKEN_use " + t.image);
        break;
      case TOKEN_where:
        t = jj_consume_token(TOKEN_where);
      System.out.println("TOKEN_where " + t.image);
        break;
      case TOKEN_while:
        t = jj_consume_token(TOKEN_while);
      System.out.println("TOKEN_while " + t.image);
        break;
      case TOKEN_ARROW:
        t = jj_consume_token(TOKEN_ARROW);
      System.out.println("TOKEN_ARROW " + t.image);
        break;
      case TOKEN_PLUS_ASSIGN:
        t = jj_consume_token(TOKEN_PLUS_ASSIGN);
      System.out.println("TOKEN_PLUS_ASSIGN " + t.image);
        break;
      case TOKEN_PLUS:
        t = jj_consume_token(TOKEN_PLUS);
      System.out.println("TOKEN_PLUS " + t.image);
        break;
      case TOKEN_MINUS_ASSIGN:
        t = jj_consume_token(TOKEN_MINUS_ASSIGN);
      System.out.println("TOKEN_MINUS_ASSIGN " + t.image);
        break;
      case TOKEN_MINUS:
        t = jj_consume_token(TOKEN_MINUS);
      System.out.println("TOKEN_MINUS " + t.image);
        break;
      case TOKEN_MULTIPLY_ASSIGN:
        t = jj_consume_token(TOKEN_MULTIPLY_ASSIGN);
      System.out.println("TOKEN_MULTIPLY_ASSIGN " + t.image);
        break;
      case TOKEN_MULTIPLY:
        t = jj_consume_token(TOKEN_MULTIPLY);
      System.out.println("TOKEN_MULTIPLY " + t.image);
        break;
      case TOKEN_DIVIDE_ASSIGN:
        t = jj_consume_token(TOKEN_DIVIDE_ASSIGN);
      System.out.println("TOKEN_DIVIDE_ASSIGN " + t.image);
        break;
      case TOKEN_DIVIDE:
        t = jj_consume_token(TOKEN_DIVIDE);
      System.out.println("TOKEN_DIVIDE " + t.image);
        break;
      case TOKEN_REMAINDER_ASSIGN:
        t = jj_consume_token(TOKEN_REMAINDER_ASSIGN);
      System.out.println("TOKEN_REMAINDER_ASSIGN " + t.image);
        break;
      case TOKEN_REMAINDER:
        t = jj_consume_token(TOKEN_REMAINDER);
      System.out.println("TOKEN_REMAINDER " + t.image);
        break;
      case TOKEN_OR:
        t = jj_consume_token(TOKEN_OR);
      System.out.println("TOKEN_OR " + t.image);
        break;
      case TOKEN_BIT_OR_ASSIGN:
        t = jj_consume_token(TOKEN_BIT_OR_ASSIGN);
      System.out.println("TOKEN_BIT_OR_ASSIGN " + t.image);
        break;
      case TOKEN_BIT_OR:
        t = jj_consume_token(TOKEN_BIT_OR);
      System.out.println("TOKEN_BIT_OR " + t.image);
        break;
      case TOKEN_AND:
        t = jj_consume_token(TOKEN_AND);
      System.out.println("TOKEN_AND " + t.image);
        break;
      case TOKEN_BIT_AND_ASSIGN:
        t = jj_consume_token(TOKEN_BIT_AND_ASSIGN);
      System.out.println("TOKEN_BIT_AND_ASSIGN " + t.image);
        break;
      case TOKEN_BIT_AND:
        t = jj_consume_token(TOKEN_BIT_AND);
      System.out.println("TOKEN_BIT_AND " + t.image);
        break;
      case TOKEN_BIT_XOR_ASSIGN:
        t = jj_consume_token(TOKEN_BIT_XOR_ASSIGN);
      System.out.println("TOKEN_BIT_XOR_ASSIGN " + t.image);
        break;
      case TOKEN_BIT_XOR:
        t = jj_consume_token(TOKEN_BIT_XOR);
      System.out.println("TOKEN_BIT_XOR " + t.image);
        break;
      case TOKEN_COMMA:
        t = jj_consume_token(TOKEN_COMMA);
      System.out.println("TOKEN_COMMA " + t.image);
        break;
      case TOKEN_DOT_DOT_ASSIGN:
        t = jj_consume_token(TOKEN_DOT_DOT_ASSIGN);
      System.out.println("TOKEN_DOT_DOT_ASSIGN " + t.image);
        break;
      case TOKEN_DOT_DOT:
        t = jj_consume_token(TOKEN_DOT_DOT);
      System.out.println("TOKEN_DOT_DOT " + t.image);
        break;
      case TOKEN_DOT:
        t = jj_consume_token(TOKEN_DOT);
      System.out.println("TOKEN_DOT " + t.image);
        break;
      case TOKEN_COLON:
        t = jj_consume_token(TOKEN_COLON);
      System.out.println("TOKEN_COLON " + t.image);
        break;
      case TOKEN_SEMICOLON:
        t = jj_consume_token(TOKEN_SEMICOLON);
      System.out.println("TOKEN_SEMICOLON " + t.image);
        break;
      case TOKEN_LEFT_SHIFT_ASSIGN:
        t = jj_consume_token(TOKEN_LEFT_SHIFT_ASSIGN);
      System.out.println("TOKEN_LEFT_SHIFT_ASSIGN " + t.image);
        break;
      case TOKEN_LEFT_SHIFT:
        t = jj_consume_token(TOKEN_LEFT_SHIFT);
      System.out.println("TOKEN_LEFT_SHIFT " + t.image);
        break;
      case TOKEN_RIGHT_SHIFT_ASSIGN:
        t = jj_consume_token(TOKEN_RIGHT_SHIFT_ASSIGN);
      System.out.println("TOKEN_RIGHT_SHIFT_ASSIGN " + t.image);
        break;
      case TOKEN_RIGHT_SHIFT:
        t = jj_consume_token(TOKEN_RIGHT_SHIFT);
      System.out.println("TOKEN_RIGHT_SHIFT " + t.image);
        break;
      case TOKEN_LESS_EQUAL:
        t = jj_consume_token(TOKEN_LESS_EQUAL);
      System.out.println("TOKEN_LESS_EQUAL " + t.image);
        break;
      case TOKEN_LESS:
        t = jj_consume_token(TOKEN_LESS);
      System.out.println("TOKEN_LESS " + t.image);
        break;
      case TOKEN_GREATER_EQUAL:
        t = jj_consume_token(TOKEN_GREATER_EQUAL);
      System.out.println("TOKEN_GREATER_EQUAL " + t.image);
        break;
      case TOKEN_GREATER:
        t = jj_consume_token(TOKEN_GREATER);
      System.out.println("TOKEN_GREATER " + t.image);
        break;
      case TOKEN_DIFFERENT:
        t = jj_consume_token(TOKEN_DIFFERENT);
      System.out.println("TOKEN_DIFFERENT " + t.image);
        break;
      case TOKEN_NOT:
        t = jj_consume_token(TOKEN_NOT);
      System.out.println("TOKEN_NOT " + t.image);
        break;
      case TOKEN_EQUAL:
        t = jj_consume_token(TOKEN_EQUAL);
      System.out.println("TOKEN_EQUAL " + t.image);
        break;
      case TOKEN_ASSIGN:
        t = jj_consume_token(TOKEN_ASSIGN);
      System.out.println("TOKEN_ASSIGN " + t.image);
        break;
      case TOKEN_OPEN_PARENTHESIS:
        t = jj_consume_token(TOKEN_OPEN_PARENTHESIS);
      System.out.println("TOKEN_OPEN_PARENTHESIS " + t.image);
        break;
      case TOKEN_CLOSE_PARENTHESIS:
        t = jj_consume_token(TOKEN_CLOSE_PARENTHESIS);
      System.out.println("TOKEN_CLOSE_PARENTHESIS " + t.image);
        break;
      case TOKEN_OPEN_BRACKET:
        t = jj_consume_token(TOKEN_OPEN_BRACKET);
      System.out.println("TOKEN_OPEN_BRACKET " + t.image);
        break;
      case TOKEN_CLOSE_BRACKET:
        t = jj_consume_token(TOKEN_CLOSE_BRACKET);
      System.out.println("TOKEN_CLOSE_BRACKET " + t.image);
        break;
      case TOKEN_OPEN_BRACE:
        t = jj_consume_token(TOKEN_OPEN_BRACE);
      System.out.println("TOKEN_OPEN_BRACE " + t.image);
        break;
      case TOKEN_CLOSE_BRACE:
        t = jj_consume_token(TOKEN_CLOSE_BRACE);
      System.out.println("TOKEN_CLOSE_BRACE " + t.image);
        break;
      case TOKEN_QUESTION:
        t = jj_consume_token(TOKEN_QUESTION);
      System.out.println("TOKEN_QUESTION " + t.image);
        break;
      case TOKEN_AT:
        t = jj_consume_token(TOKEN_AT);
      System.out.println("TOKEN_AT " + t.image);
        break;
      case TOKEN_TILDE:
        t = jj_consume_token(TOKEN_TILDE);
      System.out.println("TOKEN_TILDE " + t.image);
        break;
      case TOKEN_DECIMAL_FLOAT_LITERAL:
        t = jj_consume_token(TOKEN_DECIMAL_FLOAT_LITERAL);
      System.out.println("TOKEN_DECIMAL_FLOAT_LITERAL " + t.image);
        break;
      case TOKEN_BINARY_LITERAL:
        t = jj_consume_token(TOKEN_BINARY_LITERAL);
      System.out.println("TOKEN_BINARY_LITERAL " + t.image);
        break;
      case TOKEN_OCTAL_LITERAL:
        t = jj_consume_token(TOKEN_OCTAL_LITERAL);
      System.out.println("TOKEN_OCTAL_LITERAL " + t.image);
        break;
      case TOKEN_DECIMAL_LITERAL:
        t = jj_consume_token(TOKEN_DECIMAL_LITERAL);
      System.out.println("TOKEN_DECIMAL_LITERAL " + t.image);
        break;
      case TOKEN_HEX_LITERAL:
        t = jj_consume_token(TOKEN_HEX_LITERAL);
      System.out.println("TOKEN_HEX_LITERAL " + t.image);
        break;
      case TOKEN_CHAR_LITERAL:
        t = jj_consume_token(TOKEN_CHAR_LITERAL);
      System.out.println("TOKEN_CHAR_LITERAL " + t.image);
        break;
      case TOKEN_STRING_LITERAL:
        t = jj_consume_token(TOKEN_STRING_LITERAL);
      System.out.println("TOKEN_STRING_LITERAL " + t.image);
        break;
      case TOKEN_ID:
        t = jj_consume_token(TOKEN_ID);
      System.out.println("TOKEN_ID " + t.image);
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(0);
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public CompiladorTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[2];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0xffffff00,0xffffff00,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x1fffffff,0x1fffffff,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0xfffffff8,0xfffffff8,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0x38f5ffff,0x38f5ffff,};
   }

  /** Constructor with InputStream. */
  public Compilador(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Compilador(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new CompiladorTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public Compilador(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new CompiladorTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public Compilador(CompiladorTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(CompiladorTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List jj_expentries = new java.util.ArrayList();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[127];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 2; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 127; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

}
